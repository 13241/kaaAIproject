ce fichier est un commentaire détaillant l'algorithme de la méthode :

_stateObjective

En synthèse : l'algorithme consiste en la série d'actions/choix suivante :

	on essaye tout d'abord d'accomplir l'objectif en réalisant tous les mouvements
	horizontaux puis tous les mouvements verticaux.

Si cela échoue :

	on tente d'effectuer un détour pour contourner l'obstacle rencontré

si cela échoue :

	on tente de contourner l'obstacle sans effectuer de détour	

si cela échoue et qu'on a réalisé des poussées de chevalier avant de rencontrer
l'obstacle : 

	on annule la dernière poussée de chevalier en indiquant un obstacle dans
	cette direction et on reprend l'algorithme depuis le point précédant la 
	poussée

En détails : 	
	
reçoit : 
	peopleState : un tableau contenant les noms des pions aux index correspondant
	à leur position sur le terrain de jeu.
	kingState : l'état de santé du roi
	iPos : la position du pion devant accomplir l'objectif
	fPos : la position de la case sur laquelle doit être accompli l'objectif
	objective : l'objectif
	APAvailable : les AP disponibles pour accomplir l'objectif
	nDetour : le nombre de détours autorisés pour accomplir l'objectif
	dirPrevious : la direction de la case précédente du pion acteur
	
-?- si l'objectif est un déplacement et qu'il doit être effectué sur la case
	sur laquelle se trouve le pion acteur :
	
	-.- l'objectif est accompli, la fonction retourne un move vide
	
-?- idem + l'objectif n'est ni un déplacement ni révéler un assassin :
	
	-.- l'objectif est illogique, retourne None (but = générer une erreur)

-v- x, y sont respectivement les distances à parcourir verticalement, 
	horizontalement

-v- xdir, ydir ET ixdir, iydir sont respectivement les orientations dans lesquelles
	doivent être parcourues ces distances ET leurs opposées
	
-!- la première instruction est de parcourir toute la distance horizontale d'abord,
	ensuite de parcourir toute la distance verticale pour effectuer l'action
	-?- si une des distance est nulle, aucun déplacement n'est effectué dans
		cette direction

-v- regress=True indique qu'on ne prend pas la valeur de stated telle quelle (on en
	prend une partie seulement)
	
-?- si la première instruction consiste à revenir sur ses pas :

	-!- on annule la série d'instructions en indiquant à l'algorithme que la 
		direction "retourner sur ses pas" est un chemin bloqué
		
	sinon :
	
	-!- on teste la légalité de la série d'instructions
	
-v- forceEnded=True indique que la boucle s'est terminée faute de nouvelle
	possibilité de chemin trouvée
	
-v- detourEnded=True indique que la boucle s'est terminée parce qu'une
	possibilité de détour a été trouvée
	
-O- Tant que la série d'instruction n'est pas légale on continue à chercher
	
	-?- si on a le droit de faire des kills : 
		
		-?- si on ne revient pas sur ses pas :
			
			-!- on tente de tuer l'obstacle et de prendre sa place. On 
				rappelle l'algorithme à partir de cet endroit comme s'
				il s'agissait d'un nouvel objectif
	
	-?- si on a le droit de faire des détours :
	
		-?- si la direction bloquée est [vertical sens objectif] :
			
			-?- s'il ne reste plus aucun deplacement à faire dans la direction
				[horizontal sens objectif] :
				
				-?- si la direction [horizontal sens objectif] n'est pas
					la direction précédente :
					
					-!- on effectue un détour dans la direction 
						[horizontal sens objectif] en rappelant l'algorithme
						à partir de ce détour comme s'il s'agissait d'un 
						nouvel objectif
					
					sinon :
					
					-!- on autorise l'algorithme à tester la direction opposée
					
			-?- s'il en reste ou que [horizontal sens objectif] a échoué et que
				[horizontal opposée objectif] n'est pas la direction précédente :
				
				-!- on effectue un détour dans la direction 
					[horizontal opposé objectif] en rappelant l'algorithme
					à partir de ce détour comme s'il sagissait d'un
					nouvel objectif
					
			sinon si la direction bloquée est [horizontal sens objectif] :
			
			-?- s'il ne reste plus aucun déplacement à faire dans la direction
				[vertical sens objectif] :
				
				-?- si la direction [vertical sens objectif] n'est pas
					la direction précédente :
					
					-!- on effectue un détour dans la direction 
						[vertical sens objectif] en rappelant l'algorithme
						à partir de ce détour comme s'il s'agissait d'un
						nouvel objectif
						
					sinon :
					
					-!- on autorise l'algorithme à tester la direction opposée
					
			-?- s'il en reste ou que [vertical sens objectif] a échoué et que
				[vertical opposé objectif] n'est pas la direction précédente : 
				
				-!- on effectue un détour dans la direction 
					[vertical opposé objectif] en rappelant l'algorithme
					à partir de ce détour comme s'il s'agissait d'un
					nouvel objectif
					
	-?- Aucun détour n'a pu être réalisé : algorithme sans détour :
		si la direction bloquée est horizontale ET qu'on peut
		encore faire au moins un mouvement dans la direction 
		verticale : 
		
		-!- On insère un mouvement vertical
			puis on finit les horizontaux et ensuite les verticaux
			
		sinon si la direction bloquée est verticale ET qu'on peut
		encore faire au moins deux mouvements dans la direction verticale 
		ET qu'on a déjà fait au moins un mouvement horizontal :
		
		-!- on annule le dernier mouvement horizontal valide, on ajoute deux
			mouvements verticaux, et on met ensuite tous les horizontaux restant
			suivis de tous les verticaux
			
		sinon si des poussées de chevalier ont été effectuées dans la
		série de mouvements valides :
		
		-!- on annule le dernier mouvement ayant poussé un pion et on indique
			à l'algorithme que la direction de ce mouvement est bloquée
			
		sinon :
		
		-!- on indique à l'algorithme qu'il n'est pas possible de compléter
			l'objectif
			